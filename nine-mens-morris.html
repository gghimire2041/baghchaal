<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nine Men's Morris - Medieval Strategy</title>
    <meta name="description" content="Play Nine Men's Morris - the ancient game of mills and strategic positioning!">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Inter:wght@300;400;500;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .back-button {
            position: absolute;
            top: 2rem;
            left: 2rem;
            background: linear-gradient(45deg, #4A90E2, #357ABD);
            border: none;
            padding: 12px 24px;
            color: white;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(74, 144, 226, 0.3);
            z-index: 100;
        }
        
        .back-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(74, 144, 226, 0.5);
        }
        
        .game-container {
            min-height: 100vh;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .game-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        
        .game-title {
            font-family: 'Cinzel', serif;
            font-size: 3.5rem;
            color: #FFD700;
            margin-bottom: 1rem;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }
        
        .game-subtitle {
            font-size: 1.2rem;
            color: #B8860B;
            margin-bottom: 2rem;
        }
        
        .cultural-info {
            max-width: 700px;
            text-align: center;
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border-left: 4px solid #FFD700;
            color: #E0E0E0;
            line-height: 1.6;
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            max-width: 600px;
            width: 100%;
            margin-bottom: 2rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        
        .player-info {
            text-align: center;
            flex: 1;
        }
        
        .white-player { color: #FFFFFF; }
        .blue-player { color: #4A90E2; }
        
        .morris-board {
            width: 500px;
            height: 500px;
            position: relative;
            background: linear-gradient(135deg, #8B4513, #654321);
            border: 6px solid #5D4E37;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            margin-bottom: 2rem;
            padding: 20px;
        }
        
        .board-lines {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 460px;
            height: 460px;
        }
        
        .board-line {
            position: absolute;
            background: #FFD700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        .morris-point {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: radial-gradient(circle, #FFEF94, #FFD700);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
            border: 3px solid #B8860B;
            z-index: 10;
        }
        
        .morris-point:hover {
            transform: scale(1.15);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.7);
        }
        
        .morris-point.valid-move {
            animation: moveHint 1s infinite ease-in-out;
            box-shadow: 0 0 25px #00FF00;
        }
        
        @keyframes moveHint {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }
        
        .morris-point.removable {
            animation: removeHint 1s infinite ease-in-out;
            box-shadow: 0 0 25px #FF0000;
        }
        
        @keyframes removeHint {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        
        .morris-piece {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.8rem;
            position: relative;
            animation: placePiece 0.5s ease-out;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        @keyframes placePiece {
            0% { transform: scale(0) rotate(180deg); opacity: 0; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        
        .morris-piece:hover {
            transform: scale(1.1);
        }
        
        .morris-piece.white {
            background: radial-gradient(circle at 30% 30%, #FFFFFF, #E0E0E0);
            border: 3px solid #CCCCCC;
            color: #333333;
        }
        
        .morris-piece.blue {
            background: radial-gradient(circle at 30% 30%, #4A90E2, #357ABD);
            border: 3px solid #2E5BDA;
            color: #FFFFFF;
        }
        
        .morris-piece.selected {
            transform: scale(1.2);
            box-shadow: 0 0 30px rgba(255, 215, 0, 1);
            animation: selectedPulse 0.8s infinite alternate;
        }
        
        @keyframes selectedPulse {
            from { box-shadow: 0 0 30px rgba(255, 215, 0, 1); }
            to { box-shadow: 0 0 40px rgba(255, 215, 0, 1), 0 0 60px rgba(255, 215, 0, 0.5); }
        }
        
        .phase-indicator {
            background: linear-gradient(45deg, #9B59B6, #8E44AD);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            display: inline-block;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 15px rgba(155, 89, 182, 0.3);
        }
        
        .controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 2rem;
        }
        
        .control-button {
            background: linear-gradient(45deg, #4A90E2, #357ABD);
            border: none;
            padding: 12px 24px;
            color: white;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(74, 144, 226, 0.3);
        }
        
        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(74, 144, 226, 0.5);
        }
        
        .game-status {
            text-align: center;
            font-size: 1.3rem;
            font-weight: 600;
            margin: 1rem 0;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            max-width: 600px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .score-board {
            display: flex;
            justify-content: space-around;
            max-width: 600px;
            width: 100%;
            margin-bottom: 2rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        
        .score-item {
            text-align: center;
        }
        
        .score-label {
            font-size: 0.9rem;
            color: #B8860B;
            margin-bottom: 0.5rem;
        }
        
        .score-value {
            font-size: 2rem;
            font-weight: bold;
        }
        
        .win-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .win-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            padding: 3rem;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            border: 3px solid #FFD700;
            animation: modalAppear 0.5s ease-out;
            min-width: 400px;
        }
        
        @keyframes modalAppear {
            0% { transform: scale(0.5) rotate(5deg); opacity: 0; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        
        .win-title {
            font-family: 'Cinzel', serif;
            font-size: 3rem;
            margin-bottom: 1rem;
            color: #FFD700;
            animation: titleGlow 1s ease-in-out infinite alternate;
        }
        
        @keyframes titleGlow {
            from { text-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
            to { text-shadow: 0 0 30px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.3); }
        }
        
        .play-button {
            background: linear-gradient(45deg, #FF6B35, #F7931E);
            border: none;
            padding: 12px 30px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 0.5rem;
        }
        
        .play-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 107, 53, 0.6);
        }
        
        @media (max-width: 768px) {
            .morris-board {
                width: 400px;
                height: 400px;
            }
            
            .board-lines {
                width: 360px;
                height: 360px;
            }
            
            .morris-point {
                width: 40px;
                height: 40px;
            }
            
            .morris-piece {
                width: 50px;
                height: 50px;
                font-size: 1.5rem;
            }
            
            .game-title {
                font-size: 2.5rem;
            }
            
            .back-button {
                top: 1rem;
                left: 1rem;
            }
        }
    </style>
</head>
<body>
    <button class="back-button" onclick="backToMenu()">‚Üê Back to Games</button>
    
    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title">‚óØ Nine Men's Morris ‚óØ</h1>
            <p class="game-subtitle">Medieval Strategy Game</p>
        </div>
        
        <div class="cultural-info">
            <strong>Medieval Mastery:</strong> Dating back to the Roman Empire and flourishing in medieval Europe, Nine Men's Morris (also called Mills) is a game of strategic positioning. Form mills of three pieces in a row to capture your opponent's pieces, but beware - they can move freely once reduced to three pieces!
        </div>
        
        <div class="score-board">
            <div class="score-item">
                <div class="score-label">You (White)</div>
                <div class="score-value white-player" id="playerScore">0</div>
            </div>
            <div class="score-item">
                <div class="score-label">Pieces Left</div>
                <div class="score-value" style="color: #FFD700;"><span id="playerPieces">9</span> vs <span id="aiPieces">9</span></div>
            </div>
            <div class="score-item">
                <div class="score-label">AI (Blue)</div>
                <div class="score-value blue-player" id="aiScore">0</div>
            </div>
        </div>
        
        <div class="phase-indicator" id="phaseIndicator">Phase 1: Placing Pieces</div>
        
        <div class="game-status" id="gameStatus">Your turn! Place a white piece on any empty point.</div>
        
        <div class="morris-board" id="gameBoard">
            <div class="board-lines" id="boardLines"></div>
        </div>
        
        <div class="controls">
            <button class="control-button" onclick="newGame()">üîÑ New Game</button>
            <button class="control-button" onclick="toggleDifficulty()">üéØ <span id="difficultyText">AI</span></button>
            <button class="control-button" onclick="resetScore()">üìä Reset Score</button>
            <button class="control-button" id="soundToggle" onclick="toggleSound()">üîä Sound On</button>
        </div>
    </div>

    <!-- Win Modal -->
    <div class="win-modal" id="winModal">
        <div class="win-content">
            <h2 class="win-title" id="winTitle">Victory!</h2>
            <p id="winMessage">Congratulations!</p>
            <br>
            <button class="play-button" onclick="newGame(); closeWinModal();">Play Again</button>
            <button class="control-button" onclick="backToMenu();">Back to Games</button>
        </div>
    </div>

    <script>
        // Game state
        let gameState = {
            board: Array(24).fill(null), // 24 points on the board
            currentPlayer: 'white', // white (player) or blue (AI)
            phase: 1, // 1: placing, 2: moving, 3: flying
            piecesToPlace: { white: 9, blue: 9 },
            piecesOnBoard: { white: 0, blue: 0 },
            selectedPiece: null,
            gameOver: false,
            soundEnabled: true,
            difficulty: 'hard',
            scores: { player: 0, ai: 0 },
            mustRemove: false,
            millFormed: false
        };

        // Board positions (x, y coordinates for 500x500 board with 20px padding)
        const POSITIONS = [
            // Outer square
            [0, 0], [230, 0], [460, 0],
            [0, 230], [460, 230],
            [0, 460], [230, 460], [460, 460],
            // Middle square  
            [77, 77], [230, 77], [383, 77],
            [77, 230], [383, 230],
            [77, 383], [230, 383], [383, 383],
            // Inner square
            [154, 154], [230, 154], [307, 154],
            [154, 230], [307, 230],
            [154, 307], [230, 307], [307, 307]
        ];

        // Mills (lines of 3) - indices into POSITIONS array
        const MILLS = [
            // Outer square
            [0, 1, 2], [3, 4], [5, 6, 7], [0, 3, 5], [2, 4, 7], [1, 6],
            // Middle square
            [8, 9, 10], [11, 12], [13, 14, 15], [8, 11, 13], [10, 12, 15], [9, 14],
            // Inner square
            [16, 17, 18], [19, 20], [21, 22, 23], [16, 19, 21], [18, 20, 23], [17, 22],
            // Connecting lines
            [1, 9, 17], [6, 14, 22], [3, 11, 19], [4, 12, 20]
        ];

        // Adjacent connections for movement
        const ADJACENCIES = [
            [1, 3], [0, 2, 9], [1, 4], [0, 5, 11], [2, 7, 12], [3, 6], [5, 7, 14], [4, 6],
            [9, 11], [1, 8, 10, 17], [9, 12], [3, 8, 13, 19], [4, 10, 15, 20], [11, 14], [6, 13, 15, 22], [12, 14],
            [17, 19], [9, 16, 18], [17, 20], [11, 16, 21], [12, 18, 23], [19, 22], [14, 21, 23], [20, 22]
        ];

        function backToMenu() {
            window.location.href = 'index.html';
        }

        function initializeGame() {
            gameState.board = Array(24).fill(null);
            gameState.currentPlayer = 'white';
            gameState.phase = 1;
            gameState.piecesToPlace = { white: 9, blue: 9 };
            gameState.piecesOnBoard = { white: 0, blue: 0 };
            gameState.selectedPiece = null;
            gameState.gameOver = false;
            gameState.mustRemove = false;
            gameState.millFormed = false;
            
            createBoard();
            updateGameStatus();
            updatePhaseIndicator();
            updatePieceCount();
        }

        function createBoard() {
            const board = document.getElementById('gameBoard');
            const linesContainer = document.getElementById('boardLines');
            
            // Clear existing elements except lines container
            Array.from(board.children).forEach(child => {
                if (child !== linesContainer) {
                    child.remove();
                }
            });
            
            // Create board lines
            createBoardLines();
            
            // Create points
            for (let i = 0; i < 24; i++) {
                const point = document.createElement('div');
                point.className = 'morris-point';
                point.dataset.index = i;
                
                const [x, y] = POSITIONS[i];
                point.style.left = (x + 20 - 25) + 'px'; // -25 to center 50px point
                point.style.top = (y + 20 - 25) + 'px';
                
                point.addEventListener('click', () => handlePointClick(i));
                board.appendChild(point);
                
                // Add piece if exists
                if (gameState.board[i]) {
                    addPiece(point, gameState.board[i]);
                }
            }
        }

        function createBoardLines() {
            const linesContainer = document.getElementById('boardLines');
            linesContainer.innerHTML = '';
            
            const lineThickness = 4;
            
            // Helper function to create a line
            const createLine = (x1, y1, x2, y2) => {
                const line = document.createElement('div');
                line.className = 'board-line';
                
                const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
                
                line.style.width = length + 'px';
                line.style.height = lineThickness + 'px';
                line.style.left = x1 + 'px';
                line.style.top = y1 - lineThickness/2 + 'px';
                line.style.transform = `rotate(${angle}deg)`;
                line.style.transformOrigin = '0 50%';
                
                linesContainer.appendChild(line);
            };
            
            // Outer square
            createLine(0, 0, 460, 0);     // top
            createLine(460, 0, 460, 460); // right
            createLine(460, 460, 0, 460); // bottom
            createLine(0, 460, 0, 0);     // left
            
            // Middle square
            createLine(77, 77, 383, 77);     // top
            createLine(383, 77, 383, 383);   // right  
            createLine(383, 383, 77, 383);   // bottom
            createLine(77, 383, 77, 77);     // left
            
            // Inner square
            createLine(154, 154, 307, 154);   // top
            createLine(307, 154, 307, 307);   // right
            createLine(307, 307, 154, 307);   // bottom
            createLine(154, 307, 154, 154);   // left
            
            // Connecting lines
            createLine(230, 0, 230, 77);     // top center to middle
            createLine(230, 77, 230, 154);   // middle to inner top
            createLine(230, 460, 230, 383);  // bottom center to middle
            createLine(230, 383, 230, 307);  // middle to inner bottom
            createLine(0, 230, 77, 230);     // left center to middle
            createLine(77, 230, 154, 230);   // middle to inner left
            createLine(460, 230, 383, 230);  // right center to middle
            createLine(383, 230, 307, 230);  // middle to inner right
        }

        function addPiece(point, color) {
            const piece = document.createElement('div');
            piece.className = `morris-piece ${color}`;
            piece.textContent = color === 'white' ? '‚óã' : '‚óè';
            
            piece.addEventListener('click', (e) => {
                e.stopPropagation();
                const index = parseInt(point.dataset.index);
                handlePieceClick(index);
            });
            
            point.appendChild(piece);
        }

        function handlePointClick(index) {
            if (gameState.gameOver) return;
            
            if (gameState.mustRemove) {
                // Must remove opponent piece
                if (gameState.board[index] && gameState.board[index] !== gameState.currentPlayer) {
                    if (canRemovePiece(index)) {
                        removePiece(index);
                    }
                }
                return;
            }
            
            if (gameState.phase === 1) {
                // Placing phase
                if (gameState.currentPlayer === 'white' && !gameState.board[index]) {
                    placePiece(index, 'white');
                }
            } else if (gameState.phase >= 2) {
                // Moving/flying phase
                if (gameState.selectedPiece !== null) {
                    // Try to move selected piece
                    if (canMoveTo(gameState.selectedPiece, index)) {
                        movePiece(gameState.selectedPiece, index);
                    } else {
                        clearSelection();
                    }
                } else if (gameState.board[index] === gameState.currentPlayer) {
                    // Select piece
                    selectPiece(index);
                }
            }
        }

        function handlePieceClick(index) {
            if (gameState.gameOver) return;
            
            if (gameState.mustRemove) {
                // Must remove opponent piece
                if (gameState.board[index] !== gameState.currentPlayer) {
                    if (canRemovePiece(index)) {
                        removePiece(index);
                    }
                }
                return;
            }
            
            if (gameState.phase >= 2 && gameState.board[index] === gameState.currentPlayer) {
                selectPiece(index);
            }
        }

        function placePiece(index, color) {
            gameState.board[index] = color;
            gameState.piecesToPlace[color]--;
            gameState.piecesOnBoard[color]++;
            
            const point = document.querySelector(`[data-index="${index}"]`);
            addPiece(point, color);
            
            playSound('place');
            
            // Check for mill
            if (checkMill(index, color)) {
                gameState.mustRemove = true;
                gameState.millFormed = true;
                showRemovablePieces();
                updateGameStatus();
                return;
            }
            
            // Check if placing phase is over
            if (gameState.piecesToPlace.white === 0 && gameState.piecesToPlace.blue === 0) {
                gameState.phase = 2;
                updatePhaseIndicator();
            }
            
            switchPlayer();
        }

        function selectPiece(index) {
            clearSelection();
            gameState.selectedPiece = index;
            
            const point = document.querySelector(`[data-index="${index}"]`);
            const piece = point.querySelector('.morris-piece');
            if (piece) {
                piece.classList.add('selected');
            }
            
            // Show valid moves
            showValidMoves(index);
        }

        function clearSelection() {
            gameState.selectedPiece = null;
            document.querySelectorAll('.morris-piece').forEach(piece => {
                piece.classList.remove('selected');
            });
            document.querySelectorAll('.morris-point').forEach(point => {
                point.classList.remove('valid-move', 'removable');
            });
        }

        function showValidMoves(index) {
            const validMoves = getValidMoves(index);
            validMoves.forEach(moveIndex => {
                const point = document.querySelector(`[data-index="${moveIndex}"]`);
                point.classList.add('valid-move');
            });
        }

        function showRemovablePieces() {
            const opponent = gameState.currentPlayer === 'white' ? 'blue' : 'white';
            
            for (let i = 0; i < 24; i++) {
                if (gameState.board[i] === opponent && canRemovePiece(i)) {
                    const point = document.querySelector(`[data-index="${i}"]`);
                    point.classList.add('removable');
                }
            }
        }

        function getValidMoves(index) {
            const moves = [];
            
            if (gameState.phase === 3 && gameState.piecesOnBoard[gameState.currentPlayer] === 3) {
                // Flying phase - can move to any empty point
                for (let i = 0; i < 24; i++) {
                    if (!gameState.board[i]) {
                        moves.push(i);
                    }
                }
            } else {
                // Normal movement - only to adjacent empty points
                const adjacents = ADJACENCIES[index];
                for (const adj of adjacents) {
                    if (!gameState.board[adj]) {
                        moves.push(adj);
                    }
                }
            }
            
            return moves;
        }

        function canMoveTo(fromIndex, toIndex) {
            if (gameState.board[toIndex]) return false; // Target not empty
            
            if (gameState.phase === 3 && gameState.piecesOnBoard[gameState.currentPlayer] === 3) {
                return true; // Flying phase
            }
            
            return ADJACENCIES[fromIndex].includes(toIndex);
        }

        function movePiece(fromIndex, toIndex) {
            const color = gameState.board[fromIndex];
            
            gameState.board[fromIndex] = null;
            gameState.board[toIndex] = color;
            
            // Update UI
            const fromPoint = document.querySelector(`[data-index="${fromIndex}"]`);
            const toPoint = document.querySelector(`[data-index="${toIndex}"]`);
            
            fromPoint.innerHTML = '';
            addPiece(toPoint, color);
            
            clearSelection();
            playSound('move');
            
            // Check for mill
            if (checkMill(toIndex, color)) {
                gameState.mustRemove = true;
                gameState.millFormed = true;
                showRemovablePieces();
                updateGameStatus();
                return;
            }
            
            // Check for phase 3 (flying)
            if (gameState.phase === 2 && gameState.piecesOnBoard[gameState.currentPlayer] === 3) {
                gameState.phase = 3;
                updatePhaseIndicator();
            }
            
            switchPlayer();
        }

        function removePiece(index) {
            const color = gameState.board[index];
            gameState.board[index] = null;
            gameState.piecesOnBoard[color]--;
            
            const point = document.querySelector(`[data-index="${index}"]`);
            point.innerHTML = '';
            
            playSound('capture');
            clearSelection();
            
            gameState.mustRemove = false;
            gameState.millFormed = false;
            
            updatePieceCount();
            
            // Check win condition
            if (checkGameEnd()) return;
            
            // If it was AI's turn and they formed a mill, continue with AI
            if (gameState.currentPlayer === 'blue') {
                setTimeout(() => makeAIMove(), 500);
            } else {
                switchPlayer();
            }
        }

        function canRemovePiece(index) {
            const color = gameState.board[index];
            if (!color || color === gameState.currentPlayer) return false;
            
            // Can't remove piece that's part of a mill, unless all pieces are in mills
            if (isInMill(index, color)) {
                // Check if all opponent pieces are in mills
                const opponent = gameState.currentPlayer === 'white' ? 'blue' : 'white';
                for (let i = 0; i < 24; i++) {
                    if (gameState.board[i] === opponent && !isInMill(i, opponent)) {
                        return false; // Found a piece not in a mill
                    }
                }
            }
            
            return true;
        }

        function checkMill(index, color) {
            for (const mill of MILLS) {
                if (mill.includes(index)) {
                    if (mill.every(pos => gameState.board[pos] === color)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function isInMill(index, color) {
            for (const mill of MILLS) {
                if (mill.includes(index)) {
                    if (mill.every(pos => gameState.board[pos] === color)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function switchPlayer() {
            gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'blue' : 'white';
            updateGameStatus();
            
            // AI turn
            if (gameState.currentPlayer === 'blue' && !gameState.gameOver) {
                setTimeout(() => makeAIMove(), 800);
            }
        }

        function makeAIMove() {
            if (gameState.gameOver) return;
            
            if (gameState.mustRemove) {
                // AI must remove a piece
                const removablePieces = [];
                for (let i = 0; i < 24; i++) {
                    if (gameState.board[i] === 'white' && canRemovePiece(i)) {
                        removablePieces.push(i);
                    }
                }
                
                if (removablePieces.length > 0) {
                    const randomIndex = Math.floor(Math.random() * removablePieces.length);
                    removePiece(removablePieces[randomIndex]);
                }
                return;
            }
            
            if (gameState.phase === 1) {
                // AI placing phase
                const emptyPoints = [];
                for (let i = 0; i < 24; i++) {
                    if (!gameState.board[i]) {
                        emptyPoints.push(i);
                    }
                }
                
                if (emptyPoints.length > 0) {
                    const randomIndex = Math.floor(Math.random() * emptyPoints.length);
                    placePiece(emptyPoints[randomIndex], 'blue');
                }
            } else {
                // AI moving phase
                const aiPieces = [];
                for (let i = 0; i < 24; i++) {
                    if (gameState.board[i] === 'blue') {
                        aiPieces.push(i);
                    }
                }
                
                // Find a valid move
                for (const piece of aiPieces) {
                    const validMoves = getValidMoves(piece);
                    if (validMoves.length > 0) {
                        const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                        movePiece(piece, randomMove);
                        return;
                    }
                }
            }
        }

        function checkGameEnd() {
            const whitePieces = gameState.piecesOnBoard.white;
            const bluePieces = gameState.piecesOnBoard.blue;
            
            // Less than 3 pieces means loss
            if (whitePieces < 3 && gameState.phase >= 2) {
                handleGameEnd('blue');
                return true;
            } else if (bluePieces < 3 && gameState.phase >= 2) {
                handleGameEnd('white');
                return true;
            }
            
            // No valid moves means loss
            if (gameState.phase >= 2) {
                const currentPlayerPieces = [];
                for (let i = 0; i < 24; i++) {
                    if (gameState.board[i] === gameState.currentPlayer) {
                        currentPlayerPieces.push(i);
                    }
                }
                
                const hasValidMoves = currentPlayerPieces.some(piece => getValidMoves(piece).length > 0);
                if (!hasValidMoves) {
                    const winner = gameState.currentPlayer === 'white' ? 'blue' : 'white';
                    handleGameEnd(winner);
                    return true;
                }
            }
            
            return false;
        }

        function handleGameEnd(winner) {
            gameState.gameOver = true;
            
            if (winner === 'white') {
                gameState.scores.player++;
                showWinModal('üéâ You Win! üéâ', 'Masterful mill formations!');
                playSound('win');
            } else {
                gameState.scores.ai++;
                showWinModal('ü§ñ AI Wins!', 'The AI outmaneuvered you!');
                playSound('lose');
            }
            
            updateScoreDisplay();
        }

        function updatePieceCount() {
            document.getElementById('playerPieces').textContent = gameState.piecesOnBoard.white;
            document.getElementById('aiPieces').textContent = gameState.piecesOnBoard.blue;
        }

        function updatePhaseIndicator() {
            const indicator = document.getElementById('phaseIndicator');
            const phases = {
                1: 'Phase 1: Placing Pieces',
                2: 'Phase 2: Moving Pieces', 
                3: 'Phase 3: Flying (3 pieces left)'
            };
            indicator.textContent = phases[gameState.phase];
        }

        function updateGameStatus() {
            const status = document.getElementById('gameStatus');
            if (gameState.gameOver) return;
            
            if (gameState.mustRemove) {
                if (gameState.currentPlayer === 'white') {
                    status.textContent = 'Mill formed! Click on a blue piece to remove it.';
                    status.style.color = '#FF6B35';
                } else {
                    status.textContent = 'AI formed a mill and is removing your piece...';
                    status.style.color = '#4A90E2';
                }
                return;
            }
            
            if (gameState.currentPlayer === 'white') {
                if (gameState.phase === 1) {
                    status.textContent = 'Your turn! Place a white piece on any empty point.';
                } else {
                    status.textContent = 'Your turn! Click a white piece to move it.';
                }
                status.style.color = '#FFFFFF';
            } else {
                status.textContent = 'AI is thinking...';
                status.style.color = '#4A90E2';
            }
        }

        function playSound(type) {
            if (!gameState.soundEnabled) return;
            
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            if (type === 'place') {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);
                
                osc.frequency.value = 600;
                osc.type = 'sine';
                gain.gain.setValueAtTime(0.3, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                
                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + 0.2);
            } else if (type === 'move') {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);
                
                osc.frequency.value = 400;
                osc.type = 'triangle';
                gain.gain.setValueAtTime(0.3, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + 0.3);
            } else if (type === 'capture') {
                // Mill/capture sound
                [500, 400, 300].forEach((freq, i) => {
                    setTimeout(() => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.frequency.value = freq;
                        osc.type = 'square';
                        gain.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        osc.start(audioContext.currentTime);
                        osc.stop(audioContext.currentTime + 0.2);
                    }, i * 80);
                });
            } else if (type === 'win') {
                // Victory fanfare
                [523, 659, 784, 1047].forEach((freq, i) => {
                    setTimeout(() => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.frequency.value = freq;
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                        osc.start(audioContext.currentTime);
                        osc.stop(audioContext.currentTime + 0.4);
                    }, i * 150);
                });
            } else if (type === 'lose') {
                // Losing sound
                [400, 350, 300, 250].forEach((freq, i) => {
                    setTimeout(() => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.frequency.value = freq;
                        osc.type = 'sawtooth';
                        gain.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        osc.start(audioContext.currentTime);
                        osc.stop(audioContext.currentTime + 0.3);
                    }, i * 100);
                });
            }
        }

        function showWinModal(title, message) {
            document.getElementById('winTitle').textContent = title;
            document.getElementById('winMessage').textContent = message;
            document.getElementById('winModal').style.display = 'flex';
        }

        function closeWinModal() {
            document.getElementById('winModal').style.display = 'none';
        }

        function updateScoreDisplay() {
            document.getElementById('playerScore').textContent = gameState.scores.player;
            document.getElementById('aiScore').textContent = gameState.scores.ai;
        }

        function newGame() {
            closeWinModal();
            initializeGame();
        }

        function toggleDifficulty() {
            const difficulties = ['easy', 'medium', 'hard'];
            const currentIndex = difficulties.indexOf(gameState.difficulty);
            const nextIndex = (currentIndex + 1) % difficulties.length;
            gameState.difficulty = difficulties[nextIndex];
            
            document.getElementById('difficultyText').textContent = 'AI';
        }

        function resetScore() {
            gameState.scores = { player: 0, ai: 0 };
            updateScoreDisplay();
        }

        function toggleSound() {
            gameState.soundEnabled = !gameState.soundEnabled;
            const button = document.getElementById('soundToggle');
            button.textContent = gameState.soundEnabled ? 'üîä Sound On' : 'üîá Sound Off';
        }

        // Initialize game
        document.addEventListener('DOMContentLoaded', () => {
            initializeGame();
            updateScoreDisplay();
        });
    </script>
</body>
</html>
